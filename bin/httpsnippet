#!/usr/bin/env node

const { red, cyan, magenta, green, yellow } = require('chalk');
const cmd = require('commander');
const fs = require('fs');
const readFile = require('fs-readfile-promise');
const writeFile = require('fs-writefile-promise');
const HTTPSnippet = require('..');
const path = require('path');
const pkg = require('../package.json');

const bad = message => console.error(`${red('✖')} ${message}`);
const good = message => console.log(`${green('✓')} ${message}`);

cmd
  .version(pkg.version)
  .usage('[options] <files ...>')
  .option('-t, --target <target>', 'target output')
  .option('-c, --client [client]', 'target client library')
  .option('-o, --output <directory>', 'write output to directory')
  .option('-x, --extra [{"optionKey": "optionValue"}]', 'provide extra options for the target/client')
  .parse(process.argv);

if (!cmd.args.length || !cmd.target) {
  cmd.help();
}

let extraOptions;
if (cmd.extra) {
  try {
    extraOptions = JSON.parse(cmd.extra);
  } catch (e) {
    bad(`failed to parse options ${cyan.bold(cmd.extra)} (should be JSON)`);
    process.exit();
  }
}

let dir;
if (cmd.output) {
  dir = path.resolve(cmd.output);

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir);
  }
}

cmd.args.forEach(fileName => {
  const file = path.basename(fileName);

  readFile(fileName)
    .then(JSON.parse)

    .catch(e => {
      bad(`${cyan.bold(file)} failed to read JSON: ${red(e.message)}`);
    })

    .then(data => new HTTPSnippet(data))

    .catch(e => {
      e.errors.forEach(({ field, value, message }) => {
        bad(`${cyan.bold(file)} failed validation: (${cyan.italic(field)}: ${magenta.italic(value)}) ${red(message)}`);
      });
    })

    .then(snippet => snippet.convert(cmd.target, cmd.client, extraOptions))
    .then(output => {
      if (!output) {
        const targetNames = HTTPSnippet.availableTargets()
          .map(target => target.key)
          .join(', ');
        return bad(`${red(cmd.target)} is not a valid target. Valid targets: ${cyan(targetNames)}`);
      }

      // print
      if (!cmd.output) {
        return good(`${cyan.bold(file)} > ${yellow(cmd.target)} [${yellow(cmd.client ? cmd.client : 'default')}] :\n${output}`);
      }

      // write to file
      const name = path.basename(file, path.extname(file));

      const filename = path.format({
        dir,
        base: `${name}${HTTPSnippet.extname(cmd.target)}`,
      });

      return writeFile(filename, `${output}\n`, () => {
        good(`${cyan.bold(file)} > ${filename}`);
      });
    })

    .catch(e => {
      bad(`${cyan.bold(file)} fail: ${red(e.message)}`);
    });
});
